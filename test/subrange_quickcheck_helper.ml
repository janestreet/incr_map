open Core
open Import
open Quickcheck
open Quickcheck.Generator.Let_syntax
module Key = Int
module Value = Int

type map = Value.t Key.Map.t [@@deriving sexp_of, compare]

type map_op =
  [ `Add_nearby of Key.t * Value.t
  | `Remove of Key.t
  | `Update of Key.t * Value.t
  | `No_change
  ]
[@@deriving sexp_of]

let map_with_length_gen ?key_range length : map Generator.t =
  let f, t = Option.value key_range ~default:(-10 * length, 10 * length) in
  let%map l =
    Generator.list_with_length
      (2 * length)
      (Generator.both (Int.gen_uniform_incl f t) (Int.gen_uniform_incl (-10) 20000))
  in
  List.fold l ~init:Int.Map.empty ~f:(fun map (key, data) ->
    if Map.length map < length then Map.set map ~key ~data else map)
;;

let map_gen : map Generator.t =
  let%bind l1 = Generator.small_non_negative_int in
  let%bind l2 = Generator.small_non_negative_int in
  map_with_length_gen ((4 * l1) + l2)
;;

let map_op_gen ?key_range ?(none_ratio = 0.0) () : map_op Generator.t =
  let key_gen =
    match key_range with
    | None -> Generator.small_non_negative_int
    | Some (from, to_) -> Int.gen_incl from to_
  in
  let val_gen = Int.gen_uniform_incl (-10) 20000 in
  Generator.weighted_union
    [ ( 1.0 -. none_ratio
      , Generator.union
          [ (let%map k = key_gen
             and v = val_gen in
             `Add_nearby (k, v))
          ; (let%map k = key_gen
             and v = val_gen in
             `Update (k, v))
          ; (let%map k = key_gen in
             `Remove k)
          ] )
    ; none_ratio, Generator.singleton `No_change
    ]
;;

let rec apply_map_op ~search_length map = function
  | `Add_nearby (key, data) ->
    if Map.mem map key && Int.( > ) search_length 0
    then apply_map_op map (`Add_nearby (key + 1, data)) ~search_length:(search_length - 1)
    else Map.set map ~key ~data
  | `Update (key, data) ->
    (match Map.closest_key map `Greater_or_equal_to key with
     | None -> map
     | Some (key, _) -> Map.set map ~key ~data)
  | `Remove key ->
    (match Map.closest_key map `Greater_or_equal_to key with
     | None -> map
     | Some (key, _) -> Map.remove map key)
  | `No_change -> map
;;

let apply_map_op = apply_map_op ~search_length:10

let apply_map_op_incr map_var op =
  let map = Incr.Var.value map_var in
  Incr.Var.set map_var (apply_map_op map op)
;;

type range = int * int [@@deriving sexp_of, compare]

type range_op =
  [ `Change_start of int
  | `Change_end of int
  | `Next_page
  | `Prev_page
  | `Set_range of range (* not generated by default *)
  | `No_change
  ]
[@@deriving sexp_of]

let range_gen : range Generator.t =
  let%map a = Generator.small_non_negative_int
  and b = Generator.small_non_negative_int in
  if a < b then a, b else b, a
;;

let range_op_gen ?(none_ratio = 0.0) () : range_op Generator.t =
  let offset_gen =
    let%map ch = Generator.small_positive_int
    and positive = Bool.quickcheck_generator in
    if positive then ch else Int.(-ch)
  in
  Generator.weighted_union
    [ ( 1.0 -. none_ratio
      , Generator.weighted_union
          [ ( 0.4
            , let%map diff = offset_gen in
              `Change_start diff )
          ; ( 0.4
            , let%map diff = offset_gen in
              `Change_end diff )
          ; 0.1, Generator.singleton `Next_page
          ; 0.1, Generator.singleton `Prev_page
          ] )
    ; none_ratio, Generator.singleton `No_change
    ]
;;

let apply_range_op (start, end_) = function
  | `Change_start d ->
    let new_start = Int.max 0 (start + d) in
    new_start, Int.max new_start end_
  | `Change_end d -> start, Int.max start (end_ + d)
  | `Next_page ->
    let page_size = end_ - start + 1 in
    start + page_size, end_ + page_size
  | `Prev_page ->
    let page_size = end_ - start + 1 in
    Int.max 0 (start - page_size), Int.max 0 (end_ - page_size)
  | `Set_range range -> range
  | `No_change -> start, end_
;;

let apply_range_op_incr range_var op =
  let range = Incr.Var.value range_var in
  Incr.Var.set range_var (apply_range_op range op)
;;

let map_and_range_op_gen ?key_range () : (map_op * range_op) Generator.t =
  let%map m = map_op_gen ?key_range ~none_ratio:0.5 ()
  and r = range_op_gen ~none_ratio:0.5 () in
  m, r
;;
